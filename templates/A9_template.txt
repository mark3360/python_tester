import os
import re
import pandas as pd
import numpy as np
import time
from IPython.display import display
from timeout_decorator import timeout


class Test:
    def __init__(self, name, time, full_marks, test, student_function):
        self.name = name    # Name of test
        self.time = time    # Time allotted to run test in seconds 
        self.full_marks = full_marks   # Maximum marks on the test
        self.the_test = test 
        self.funct = student_function

# the_test is Function that takes in a function and tests that function, returns list containing
# marks awarded and feedback
                             
    
    
    
    
class Tester:
    feedback = ""
    marks_earned = 0
    total_marks = 0
    
    #expected is "correct" result, close is a list for awarding part marks.
    def run_test(self, test):
        student_function = test.funct
        self.total_marks += test.full_marks
        marks_awarded = 0
        self.feedback += f"{test.name}: " 
        
        if student_function == None:
            self.feedback += "Function Undefined!\n"
        else:
            try:
                @timeout(test.time)
                def f():
                    return test.the_test(student_function)
                result = f()
                marks_awarded = result[0]
                test_feedback = result[1]
                self.feedback += test_feedback
            
            except TimeoutError as e:
                self.feedback +=  f"Function {student_function.__name__} timed out with time limit {test.time}"
            except:
                self.feedback += f"Function {student_function.__name__} encountered error while running"
            
        self.marks_earned += marks_awarded
        self.feedback += "\n"
        self.feedback += f"{marks_awarded} / {test.full_marks}"
        self.feedback += "\n"
        self.feedback += "\n"


# Consumes a list of student functions (as strings), and returns the list containing the actual student functions.
def load_functions(lst):
    ans = []
    for f in lst:
        try:
            exec(f"ans.append({f})",globals(), locals())
        except:
            ans.append(None)
    return ans

##########################################################################################################
##########################################################################################################
# Define tests here.


def correct_create_paths(random_vars, S0, rf, sigma):
    randomVariables = random_vars
    N = len(random_vars)
    deltaT = 1/12

    pathArr = []

    for i in range(N):
        row = [S0]
        for j in range(12):
            newPrice = row[-1] * np.exp((rf - (sigma**2)/2)*deltaT + sigma*((deltaT**0.5))*randomVariables[j][i])
            row.append(newPrice)
        pathArr.append(row)
    
    paths = pd.DataFrame(pathArr)
    return paths

def correct_payoff_table(paths, K, T, rf, B):
    N = len(paths)
    #discounts a payment by a year per the question specifications
    def discount(pmt):
        return pmt*np.exp(-rf * T)

    #functions that calculate payoff for each option given a price path
    def EuropeanCall(path):
        return discount(max(path[12] - K, 0))

    def EuropeanPut(path):
        return discount(max(K-path[12], 0))
    
    def AveragePricePut(path):
        Sbar = path.mean()
        return discount(max(K - Sbar, 0))
    
    def FloatingLookback(path):
        Smin = path.min()
        return discount(path[12] - Smin)
    
    def upAndOut(path, B):
        for i in range(13):
            if(path[i] >= B):
                return 0
        return discount(max(path[12] - K, 0))
    
    def upAndIn(path, B):
        atLeastOne = False
        for i in range(13):
            if(path[i] >= B):
                atLeastOne = True
                break
        if atLeastOne:
            St = path[12]
            return discount(max(St - K, 0))
        else:
            return 0
    
    payoffsArr = np.zeros((N, 6))
    
    for i in range(N):
        row = paths.iloc[i]
        payoffsArr[i][0] = EuropeanCall(row)
        payoffsArr[i][1] = EuropeanPut(row)
        payoffsArr[i][2] = AveragePricePut(row)
        payoffsArr[i][3] = FloatingLookback(row)
        payoffsArr[i][4] = upAndOut(row, 90)
        payoffsArr[i][5] = upAndIn(row, 90)
        
    payoffs = pd.DataFrame(payoffsArr)
    renameDict = {0: "European Call", 1: "European Put", 2: "Average Price Put", 3: "Floating Lookback",4: "Up-and-out",5: "Up-and-in"}
    payoffs = payoffs.rename(columns=renameDict, errors="raise")
    return payoffs

def correct_statistics(payoffs):
    N = len(payoffs)
    #Statistics
    statLst = []
    for column in payoffs:
        row = []
        info = payoffs[column]
        mean = info.mean()
        sd = info.std()
        se = sd/(N**0.5)
        row.append(mean)
        row.append(se)
        row.append(mean-1.96*se)
        row.append(mean+1.96*se)
        statLst.append(row)

    stats = pd.DataFrame(statLst)
    renameDict = {0: "European Call", 1: "European Put", 2: "Average Price Put", 3: "Floating Lookback",4: "Up-and-out",5: "Up-and-in"}
    stats = stats.rename(index=renameDict, errors="raise")
    renameDict2 = {0: "Mean", 1: "Standard Error", 2: "Lower Bound", 3: "Upper Bound"}
    stats = stats.rename(columns=renameDict2, errors="raise")
    return stats



def correct_create_negative_paths(random_vars, S0, rf, sigma):
    randomVariables = random_vars
    N = len(random_vars)
    deltaT = 1/12

    pathArr = []

    for i in range(N):
        row = [S0]
        for j in range(12):
            newPrice = row[-1] * np.exp((rf - (sigma**2)/2)*deltaT + sigma*((deltaT**0.5))*(-randomVariables[j][i]))
            row.append(newPrice)
        pathArr.append(row)
    
    paths = pd.DataFrame(pathArr)
    return paths

def correct_antithetic_statistics(random_vars, S0, rf, sigma, K, T, B):
    paths1 = correct_create_paths(random_vars, S0, rf, sigma)
    paths2 = correct_create_negative_paths(random_vars, S0, rf, sigma)
    payoffs1 = correct_payoff_table(paths1, K, T, rf, B)
    payoffs2 = correct_payoff_table(paths2, K, T, rf, B)
    
    avg_payoffs = (payoffs1 + payoffs2)/2
    return correct_statistics(avg_payoffs)

test_r_vars = gen_random_vars(700, 20)

test_paths = correct_create_paths(test_r_vars, 72.25, 0.04 , 0.35)

test_payoff_table = correct_payoff_table(test_paths, 70, 1, 0.04, 90)


# Load student functions
sf = load_functions(["european_put","american_put","create_paths", "payoff_table", "statistics", "antithetic_statistics"])




def ep_1(f):
    pts = 0
    res = round(f(40,40, 0.25, -0.2, 0.1), 4)
    ans = 2.6168

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"

    return [pts, feedback] 
 
def ep_2(f):
    pts = 0
    res = round(f(41,39, 0.5, -0.2, 0.1), 4)
    ans = 4.8193

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"

    return [pts, feedback]


def ap_1(f):
    pts = 0
    res = round(f(40,40, 0.25, -0.2, 0.1), 4)
    ans = 3.4103

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"

    return [pts, feedback] 
 
 
def cp(f):
    pts = 0

    res = f(test_r_vars, 72.25, 0.04 , 0.35)
    ans = correct_create_paths(test_r_vars, 72.25, 0.04 , 0.35)

    res1 = round(res.iloc[1].iloc[12], 4)
    ans1 = round(ans.iloc[1].iloc[12], 4)

    if res1 == ans1:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res1} but expected {ans1}"

    return [pts, feedback] 

 
def pt_1(f):
    pts = 0
    feedback = ""

    ans = correct_payoff_table(test_paths, 70, 1, 0.04, 90)
    res = f(test_paths, 70, 1, 0.04, 90)

    res1 = round(res.iloc[0].iloc[0], 4)
    ans1 = round(ans.iloc[0].iloc[0], 4)
 
    res2 = round(res.iloc[0].iloc[1], 4)
    ans2 = round(ans.iloc[0].iloc[1], 4)
 
    res3 = round(res.iloc[0].iloc[2], 4)
    ans3 = round(ans.iloc[0].iloc[2], 4)
 
    res4 = round(res.iloc[0].iloc[3], 4)
    ans4 = round(ans.iloc[0].iloc[3], 4)
 
    res5 = round(res.iloc[0].iloc[4], 4)
    ans5 = round(ans.iloc[0].iloc[4], 4)
 
    res6 = round(res.iloc[0].iloc[5], 4)
    ans6 = round(ans.iloc[0].iloc[5], 4)

    if res1 == ans1:
        pts += 0.5
        feedback += "European Call Correct. "
    else:
        feedback += "European Call Incorrect. "
        
    if res2 == ans2:
        pts += 0.5
        feedback += "European Put Correct. "
    else:
        feedback += "European Put Incorrect. "

    if res3 == ans3:
        pts += 0.5
        feedback += "Average Price Put Correct. "
    else:
        feedback += "Average Price Put Incorrect. "

    if res4 == ans4:
        pts += 0.5
        feedback += "Floating Lookback Correct. "
    else:
        feedback += "Floating Lookback Incorrect. "

    if res5 == ans5:
        pts += 0.5
        feedback += "Up-and-out Correct. "
    else:
        feedback += "Up-and-out Incorrect. "

    if res6 == ans6:
        pts += 0.5
        feedback += "Up-and-in Correct. "
    else:
        feedback += "Up-and-in Incorrect. "

    return [pts, feedback] 

def pt_2(f):
    pts = 0
    feedback = ""

    ans = correct_payoff_table(test_paths, 70, 1, 0.04, 90)
    res = f(test_paths, 70, 1, 0.04, 90)

    res1 = round(res.iloc[1].iloc[0], 4)
    ans1 = round(ans.iloc[1].iloc[0], 4)
 
    res2 = round(res.iloc[1].iloc[1], 4)
    ans2 = round(ans.iloc[1].iloc[1], 4)
 
    res3 = round(res.iloc[1].iloc[2], 4)
    ans3 = round(ans.iloc[1].iloc[2], 4)
 
    res4 = round(res.iloc[1].iloc[3], 4)
    ans4 = round(ans.iloc[1].iloc[3], 4)
 
    res5 = round(res.iloc[1].iloc[4], 4)
    ans5 = round(ans.iloc[1].iloc[4], 4)
 
    res6 = round(res.iloc[1].iloc[5], 4)
    ans6 = round(ans.iloc[1].iloc[5], 4)

    if res1 == ans1:
        pts += 0.5
        feedback += "European Call Correct. "
    else:
        feedback += "European Call Incorrect. "
        
    if res2 == ans2:
        pts += 0.5
        feedback += "European Put Correct. "
    else:
        feedback += "European Put Incorrect. "

    if res3 == ans3:
        pts += 0.5
        feedback += "Average Price Put Correct. "
    else:
        feedback += "Average Price Put Incorrect. "

    if res4 == ans4:
        pts += 0.5
        feedback += "Floating Lookback Correct. "
    else:
        feedback += "Floating Lookback Incorrect. "

    if res5 == ans5:
        pts += 0.5
        feedback += "Up-and-out Correct. "
    else:
        feedback += "Up-and-out Incorrect. "

    if res6 == ans6:
        pts += 0.5
        feedback += "Up-and-in Correct. "
    else:
        feedback += "Up-and-in Incorrect. "

    return [pts, feedback] 

def stats(f):
    pts = 0
    feedback = ""

    ans = correct_statistics(test_payoff_table)
    res = f(test_payoff_table)

    res1 = round(res.iloc[1].iloc[0], 4)
    ans1 = round(ans.iloc[1].iloc[0], 4)
 
    res2 = round(res.iloc[1].iloc[1], 4)
    ans2 = round(ans.iloc[1].iloc[1], 4)
 
    res3 = round(res.iloc[1].iloc[2], 4)
    ans3 = round(ans.iloc[1].iloc[2], 4)
 
    res4 = round(res.iloc[1].iloc[3], 4)
    ans4 = round(ans.iloc[1].iloc[3], 4)
 

    if res1 == ans1:
        pts += 1
        feedback += "Mean Correct. "
    else:
        feedback += "Mean Incorrect. "
        
    if res2 == ans2:
        pts += 1
        feedback += "Standard Error Correct. "
    else:
        feedback += "Standard Error Incorrect. "

    if res3 == ans3:
        pts += 1
        feedback += "Lower Bound Correct. "
    else:
        feedback += "Lower Bound Incorrect. "

    if res4 == ans4:
        pts += 1
        feedback += "Upper Bound Correct. "
    else:
        feedback += "Upper Bound Incorrect. "


    return [pts, feedback] 

def anti_stats(f):
    pts = 0
    feedback = ""

    ans = correct_antithetic_statistics(test_r_vars, 72.25, 0.04, 0.35,  70, 1, 90)
    res = f(test_r_vars, 72.25, 0.04, 0.35,  70, 1, 90)

    res1 = round(res.iloc[1].iloc[0], 4)
    ans1 = round(ans.iloc[1].iloc[0], 4)
 
    res2 = round(res.iloc[1].iloc[1], 4)
    ans2 = round(ans.iloc[1].iloc[1], 4)
 
    res3 = round(res.iloc[1].iloc[2], 4)
    ans3 = round(ans.iloc[1].iloc[2], 4)
 
    res4 = round(res.iloc[1].iloc[3], 4)
    ans4 = round(ans.iloc[1].iloc[3], 4)
 

    if res1 == ans1:
        pts += 1
        feedback += "Mean Correct. "
    else:
        feedback += "Mean Incorrect. "
        
    if res2 == ans2:
        pts += 1
        feedback += "Standard Error Correct. "
    else:
        feedback += "Standard Error Incorrect. "

    if res3 == ans3:
        pts += 1
        feedback += "Lower Bound Correct. "
    else:
        feedback += "Upper Bound Incorrect. "

    if res4 == ans4:
        pts += 1
        feedback += "Floating Lookback Correct. "
    else:
        feedback += "Floating Lookback Incorrect. "


    return [pts, feedback] 



# Order is name, time, full_marks, test

test_1  = Test("european_put test1",10, 1,ep_1 , sf[0])
test_2  = Test("european_put test2",10, 1,ep_2 , sf[0])

test_3  = Test("american_put test1",10, 1,ap_1 , sf[1])
test_4  = Test("american_put test1",10, 1,ap_1 , sf[1])

test_5  = Test("create_paths test",10, 1,cp , sf[2])

test_6  = Test("payoff_table test1",10, 3,pt_1 , sf[3])
test_7  = Test("payoff_table test2",10, 3,pt_2 , sf[3])


test_8  = Test("statistics test",20, 4, stats , sf[4])
test_9  = Test("antithetic_statistics test",20, 4, anti_stats , sf[5])

# Place all tests in list below
the_tests = [test_1,
             test_2,
             test_3,
             test_5,
             test_6,
             test_7,
             test_8,
             test_9]


##########################################################################################################
##########################################################################################################
## The actual testing

filename = os.path.basename(__file__)
lst = filename.split(" - ")
del lst[4:]

(file_id, name, watiam, fileid) = lst


print(f"Testing {watiam}") 

feedback = f"Feedback for {watiam}:\n\n"

the_tester = Tester()
    
    
        
for test in the_tests:
    the_tester.run_test(test)

feedback += the_tester.feedback
total = the_tester.total_marks
score = the_tester.marks_earned
x = round(100*score/total, 4)


feedback += f"Total: {score}/{total}:         {x}% \n"

filename = "../feedback/" + file_id + " - " +  name + " - " +  watiam + " - " +  "feedback.txt"

with open(filename, 'w') as fp:
	fp.write(feedback)

grades_df = pd.read_csv("../grades.csv").set_index("Username")
grades_df.at["#" + watiam, "Module 9 Python Points Grade <Numeric MaxPoints:100 Weight:25 Category:Python exercises CategoryWeight:20>"] = x

grades_df.to_csv("../grades.csv")
