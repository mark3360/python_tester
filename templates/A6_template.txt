import os
import re
import pandas as pd
import numpy as np
import time
from IPython.display import display
from timeout_decorator import timeout


class Test:
    def __init__(self, name, time, full_marks, test, student_function):
        self.name = name    # Name of test
        self.time = time    # Time allotted to run test in seconds 
        self.full_marks = full_marks   # Maximum marks on the test
        self.the_test = test 
        self.funct = student_function

# the_test is Function that takes in a function and tests that function, returns list containing
# marks awarded and feedback
                             
    
    
    
    
class Tester:
    feedback = ""
    marks_earned = 0
    total_marks = 0
    
    #expected is "correct" result, close is a list for awarding part marks.
    def run_test(self, test):
        student_function = test.funct
        self.total_marks += test.full_marks
        marks_awarded = 0
        self.feedback += f"{test.name}: " 
        
        if student_function == None:
            self.feedback += "Function Undefined!\n"
        else:
            try:
                @timeout(test.time)
                def f():
                    return test.the_test(student_function)
                result = f()
                marks_awarded = result[0]
                test_feedback = result[1]
                self.feedback += test_feedback
            
            except TimeoutError as e:
                self.feedback +=  f"Function {student_function.__name__} timed out with time limit {test.time}"
            except:
                self.feedback += f"Function {student_function.__name__} encountered error while running"
            
        self.marks_earned += marks_awarded
        self.feedback += "\n"
        self.feedback += f"{marks_awarded} / {test.full_marks}"
        self.feedback += "\n"
        self.feedback += "\n"


# Consumes a list of student functions (as strings), and returns the list containing the actual student functions.
def load_functions(lst):
    ans = []
    for f in lst:
        try:
            exec(f"ans.append({f})",globals(), locals())
        except:
            ans.append(None)
    return ans

##########################################################################################################
##########################################################################################################
# Define tests here.

data1 = pd.DataFrame(data = {"Price in 1 Year" : [32, 43, 54],
                            "Probability" : [0.3, 0.4, 0.3]})

data2 = pd.DataFrame(data = {"Price in 1 Year" : [727, 41, 52, 65],
                            "Probability" : [0.4, 0.3, 0.2, 0.1]})

partBdata1 = pd.DataFrame(data = {
    "PERMNO" : ["10000","10000","10000","20000","20000","20000","20000"],
    "date" : ["1970-01-30", "1970-02-30","1970-03-30","1970-01-30", "1970-02-30","1970-03-30","1970-04-30"],
    "CUSIP"  : ["10000","10000","10000","20000","20000","20000","20000"],
    "RET" : [0.2,0.4,-0.1,0.5,0.6,-0.2,-0.1]
})


def er_1(f):
    pts = 0
    res = round(f(data1,40),4)
    ans = 0.075
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def er_2(f):
    pts = 0
    res = round(f(data2,30),4)
    ans = 9.6667
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def vol_1(f):
    pts = 0
    res = round(f(data1,40),4)
    ans = 0.2130
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def vol_2(f):
    pts = 0
    res = round(f(data2,30),4)
    ans = 11.0795
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def int_1(f):
    pts = 0
    res = f(data1,40)
    res0 = round(res[0], 4)
    res1 = round(res[1], 4)
    ans0 = -0.1660
    ans1 = 0.3160
    
    if (res1 == ans1) and (res0 == ans0) :
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned [{res0},{res1}]  but expected [{ans0},{ans1}]"
    return [pts, feedback]

def int_2(f):
    pts = 0
    res = f(data2,30)
    res0 = round(res[0], 4)
    res1 = round(res[1], 4)
    ans0 = -1.1912
    ans1 = 20.5245
    
    if (res1 == ans1) and (res0 == ans0) :
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned [{res0},{res1}]  but expected [{ans0},{ans1}]"
    return [pts, feedback]

def erc(f):
    pts = 0
    res = round(f(-0.6,0.1,0.02),4)
    ans = -0.028
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def cd(f):
    pts = 0
    res = len(f("monthlycrsp_mod6.csv"))
    ans = 636
    
    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed"
    return [pts, feedback]

def ar_1(f):
    pts = 0
    res = f(partBdata1.copy())
    res = round(res.iloc[0]["Average Return"], 4)
    ans = 0.1667    

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def ar_2(f):
    pts = 0
    res = f(partBdata1.copy())
    res = round(res.iloc[1]["Average Return"], 4)
    ans = 0.2

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]


def sv_1(f):
    pts = 0
    res = f(partBdata1.copy())
    res = round(res.iloc[0]["Volatility"],4)
    ans = 0.2517

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]

def sv_2(f):
    pts = 0
    res = f(partBdata1.copy())
    res = round(res.iloc[1]["Volatility"],4)
    ans = 0.4082

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]


tester_ret_df = pd.DataFrame(data = {
    "CUSIP"  : ["100","200","300","400","500","600"],
    "Average Return" : [5.92,1.07,1.11,3.12,-0.5,-0.17]
})

tester_vol_df = pd.DataFrame(data = {
    "CUSIP"  : ["100","200","300","400","500","600"],
    "Volatility" : [0.3,0.2,0.5,0.54,0.213,0.423]
})


def corr_1(f):
    pts = 0
    res = round(f(tester_ret_df, tester_vol_df), 4)
    ans = 0.1283

    if res == ans:
        feedback = "Test passed!"
        pts = 1
    else:
        feedback = f"Test failed, function returned {res} but expected {ans}"
    return [pts, feedback]



# Load student functions
sf = load_functions(["exp_return", "volatility", "interval","exp_return_capm","clean_data", "avg_return","security_volatilities", "correlation"])

# Order is name, time, full_marks, test

test_1  = Test("exp_return test1",10, 1,er_1 , sf[0])
test_2  = Test("exp_return test2",10, 1,er_2 , sf[0])
test_3  = Test("volatility test1",10, 1,vol_1 , sf[1])
test_4  = Test("volatility test2",10, 1,vol_2 , sf[1])
test_5  = Test("interval test1",10, 1,int_1 , sf[2])
test_6  = Test("interval test2",10, 1,int_2 , sf[2])
test_7  = Test("exp_return_capm test",10, 1,erc , sf[3])
test_8  = Test("clean_data test",10, 1,cd , sf[4])
test_9  = Test("avg_return test1",10, 1,ar_1 , sf[5])
test_10 = Test("avg_return test2",10, 1,ar_2 , sf[5])
test_11 = Test("security_volatilities test1",10, 1,sv_1 , sf[6])
test_12 = Test("security_volatilities test2",10, 1,sv_2 , sf[6])
test_13 = Test("correlation",10, 1,corr_1 , sf[7])


# Place all tests in list below
the_tests = [test_1,
             test_2,
             test_3,
             test_4,
             test_5,
             test_6,
             test_7,
             test_8,
             test_9,
             test_10,
             test_11,
             test_12,
             test_13]


##########################################################################################################
##########################################################################################################
## The actual testing

filename = os.path.basename(__file__)
lst = filename.split(" - ")
del lst[4:]

(file_id, name, watiam, fileid) = lst


print(f"Testing {watiam}") 

feedback = f"Feedback for {watiam}:\n\n"

the_tester = Tester()
    
    
        
for test in the_tests:
    the_tester.run_test(test)

feedback += the_tester.feedback
total = the_tester.total_marks
score = the_tester.marks_earned
x = round(100*score/total, 4)


feedback += f"Total: {score}/{total}:         {x}% \n"

filename = "../feedback/" + file_id + " - " +  name + " - " +  watiam + " - " +  "feedback.txt"

with open(filename, 'w') as fp:
	fp.write(feedback)

grades_df = pd.read_csv("../grades.csv").set_index("Username")
grades_df.at["#" + watiam, "Module 6 Python Points Grade <Numeric MaxPoints:100 Weight:6.25 Category:Python exercises CategoryWeight:20>"] = x

grades_df.to_csv("../grades.csv")
